<#@ assembly name="System" #>
<#@ assembly name="System.Collections" #>
<#@ assembly name="System.ComponentModel.Composition" #>
<#@ assembly name="System.ComponentModel.DataAnnotations" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="System.Data.DataSetExtensions" #>
<#@ assembly name="System.Net.Http" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="$(SolutionDir)ComicVine.API.DataModel\bin\Debug\ComicVine.API.DataModel.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="ComicVine.API.CodeGenerator" #>
<#@ import namespace="ComicVine.API.DataModel" #>
<#+
string CleanType(string typeName) {
	if (typeName.Contains("DataModel.")) {
		typeName = typeName.Replace("DataModel.", "");
		typeName += "Model";
		typeName = typeName.Replace(">Model", "Model>");
	}
	return typeName;
}
bool IsClassProperty(propertyInfo property, out string propertyType) {
	var originalPropertyType = property.type;
	propertyType = CleanType(property.type);
	if (IsIdentifierProperty(property)) { return false; }
	if (originalPropertyType != propertyType) { return false; }
	if (propertyType.StartsWith("List<")) { return false; }
	return true;
}
bool IsRelatedObjectProperty(propertyInfo property, out string propertyType) {
	var originalPropertyType = property.type;
	propertyType = CleanType(property.type);
	if (originalPropertyType == propertyType && !IsIdentifierProperty(property)) { return false; }
	if (propertyType.StartsWith("List<")) { return false; }
	if (propertyType == "Guid?") { return false; }
	if (propertyType == "string") { return false; }
	if (property.name == "ID" || property.name == "Id") { return false; }
	return true;
}
bool IsAssociatedObjectProperty(propertyInfo property, out string propertyType) {
	var originalPropertyType = property.type;
	propertyType = CleanType(property.type);
	if (!propertyType.StartsWith("List<")) { return false; }
	return true;
}
bool IsIdentifierProperty(propertyInfo property) {
	return (property.name.EndsWith("Id") || property.name.EndsWith("ID")) && property.type.Replace("?", "") != "Guid";
}
string PluralizeName(string original) {
	if (original.Equals("EpisodeCharacterDied")) { return "EpisodeCharactersDied"; }
	if (original.EndsWith("Person")) { return original.Replace("Person", "People"); }
	if (original.EndsWith("Series")) { return original; }
	if (original.EndsWith("Address")
		|| original.EndsWith("Hash")
		|| original.EndsWith("Alias")
		|| original.EndsWith("Status"))
	{
		return original + "es";
	}
	if (original.EndsWith("y"))
	{
		return original.Substring(0, original.Length - 1) + "ies";
	}
	var retVal = original + "s";
	return retVal;
}
void GenerateMappingTestingFile(string nameSpace, classInfo entityClass)
{
	var hasProperties = false;
	var hasRelatedProperties = false;
	var hasAssociatedProperties = false;
	var thisClassName = entityClass.name.Replace("Schema.", "");
	var thisClassNameLowerFirst = Char.ToLowerInvariant(thisClassName[0]) + thisClassName.Substring(1);
	var thisClassNamePluralized = PluralizeName(thisClassName);
	var thisClassNamePluralizedLowerFirst = Char.ToLowerInvariant(thisClassNamePluralized[0]) + thisClassNamePluralized.Substring(1);
	var baseClassName = entityClass.baseClassName;
	var baseClassNameNoShared = baseClassName.Replace("Schema.Shared.", "");
	var isRelationalTable = baseClassNameNoShared != "NameableEntityBase";
	string propertyType; #>
// <auto-generated>
// <copyright file="<#= nameSpace #>.I<#= thisClassName #>Repository.cs" company="clarityventures.com">
// Copyright (c) 2015 Clarity Ventures, Inc. All rights reserved.
// </copyright>
// <summary>Implements the <#= thisClassNamePluralized #>Repository Class.</summary>
// <remarks>This file was autogenerated using RepositoryTestingFileMaster.tt in ComicVine.API.Repositories.Testing\Repositories\CodeGenerator</remarks>
// </auto-generated>
namespace ComicVine.API.Testing.Mappings.<#= nameSpace #>
{
    using System.Collections.Generic;
    using API.Models;
    using API.Mappings;
    using DataModel.Schema;
    using Interfaces.DataModels;
    using Interfaces.Models;
    using Moq;
    using Xunit;

    public static class <#= thisClassNamePluralized #>MockingSetup
    {
        public static Mock<I<#= thisClassName #>Model> DoMockingSetupFor<#= thisClassName #>Model(int idReturnValue = 0, string name = "Stephen King")
        {
            var mock<#= thisClassName #>Model = new Mock<I<#= thisClassName #>Model>();
            // Mock Functions
            mock<#= thisClassName #>Model.Setup(m => m.Id).Returns(() => idReturnValue);
            mock<#= thisClassName #>Model.Setup(m => m.Active).Returns(() => true);
            mock<#= thisClassName #>Model.Setup(m => m.CustomKey).Returns(() => "KING-STEPHEN");
            mock<#= thisClassName #>Model.Setup(m => m.ApiDetailUrl).Returns(() => "/TEST/KING-STEPHEN");
            mock<#= thisClassName #>Model.Setup(m => m.SiteDetailUrl).Returns(() => "/TEST/KING-STEPHEN");
            mock<#= thisClassName #>Model.Setup(m => m.CreatedDate).Returns(() => new System.DateTime(2015, 10, 1));
            mock<#= thisClassName #>Model.Setup(m => m.UpdatedDate).Returns(() => null);
            //mock<#= thisClassName #>Model.Setup(m => m.Name).Returns(() => name);
            //mock<#= thisClassName #>Model.Setup(m => m.ShortDescription).Returns(() => "short");
            //mock<#= thisClassName #>Model.Setup(m => m.Description).Returns(() => "long");
<#+	foreach (var property in entityClass.properties) {
		if (!IsClassProperty(property, out propertyType)) { continue; }
		hasProperties = true;
		if (property.type.Contains("DateTime")) {#>
            mock<#= thisClassName #>Model.Setup(m => m.<#= property.name #>).Returns(() => new System.DateTime());
<#+		} else if (property.type.Contains("int")) {#>
            mock<#= thisClassName #>Model.Setup(m => m.<#= property.name #>).Returns(() => 2000);
<#+		} else if (property.type.Contains("decimal")) {#>
            mock<#= thisClassName #>Model.Setup(m => m.<#= property.name #>).Returns(() => 1.25m);
<#+		} else if (property.type.Contains("bool")) {#>
            mock<#= thisClassName #>Model.Setup(m => m.<#= property.name #>).Returns(() => true);
<#+		} else { #>
            mock<#= thisClassName #>Model.Setup(m => m.<#= property.name #>).Returns(() => "<#= property.name #>");
<#+		} #>
<#+	} // End Foreach loop (var property in entityClass.properties) // Properties #>
<#+	if (!hasProperties) { #>
            // <None>
<#+	} // End If (!hasProperties) #>
            // Related Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsRelatedObjectProperty(property, out propertyType)) { continue; }
		hasRelatedProperties = true; #>
<#+		if (IsIdentifierProperty(property)) {#>
            mock<#= thisClassName #>Model.Setup(m => m.<#= property.name #>).Returns(() => 1);
<#+		} else {#>
            mock<#= thisClassName #>Model.Setup(m => m.<#= property.name #>).Returns(() => new <#= property.type.Replace("DataModel.Schema.", "") #>Model());
<#+		} #>
<#+	} // End Foreach loop (var property in entityClass.properties) // Related #>
<#+	if (!hasRelatedProperties) { #>
            // <None>
<#+	} // End If (!hasRelatedProperties) #>
            // Associated Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsAssociatedObjectProperty(property, out propertyType)) { continue; }
		var type = propertyType.Replace("List<", "").Replace(">", "").Replace("DataModel.", "").Replace("Model", "");
		hasAssociatedProperties = true; #>
            mock<#= thisClassName #>Model.Setup(m => m.<#= property.name #>).Returns(() => new <#= property.type.Replace("DataModel.Schema.", "").Replace("List<", "List<I").Replace(">", "Model>") #>());
<#+	} // End Foreach loop (var property in entityClass.properties) // Associated #>
<#+	if (!hasAssociatedProperties) { #>
            // <None>
<#+	} // End If (!hasAssociatedProperties) #>
            // Return
            return mock<#= thisClassName #>Model;
        }

        public static Mock<I<#= thisClassName #>> DoMockingSetupFor<#= thisClassName #>(int idReturnValue = 0, string name = "Stephen King")
        {
            var mock<#= thisClassName #> = new Mock<I<#= thisClassName #>>();
            // Mock Functions
            mock<#= thisClassName #>.Setup(m => m.Id).Returns(() => idReturnValue);
            mock<#= thisClassName #>.Setup(m => m.Active).Returns(() => true);
            mock<#= thisClassName #>.Setup(m => m.CustomKey).Returns(() => "KING-STEPHEN");
            mock<#= thisClassName #>.Setup(m => m.ApiDetailUrl).Returns(() => "/TEST/KING-STEPHEN");
            mock<#= thisClassName #>.Setup(m => m.SiteDetailUrl).Returns(() => "/TEST/KING-STEPHEN");
            mock<#= thisClassName #>.Setup(m => m.CreatedDate).Returns(() => new System.DateTime(2015, 10, 1));
            mock<#= thisClassName #>.Setup(m => m.UpdatedDate).Returns(() => null);
            //mock<#= thisClassName #>.Setup(m => m.Name).Returns(() => name);
            //mock<#= thisClassName #>.Setup(m => m.ShortDescription).Returns(() => "short");
            //mock<#= thisClassName #>.Setup(m => m.Description).Returns(() => "long");
<#+	foreach (var property in entityClass.properties) {
		if (!IsClassProperty(property, out propertyType)) { continue; }
		hasProperties = true;
		if (property.type.Contains("DateTime")) {#>
            mock<#= thisClassName #>.Setup(m => m.<#= property.name #>).Returns(() => new System.DateTime());
<#+		} else if (property.type.Contains("int")) {#>
            mock<#= thisClassName #>.Setup(m => m.<#= property.name #>).Returns(() => 2000);
<#+		} else if (property.type.Contains("decimal")) {#>
            mock<#= thisClassName #>.Setup(m => m.<#= property.name #>).Returns(() => 1.25m);
<#+		} else if (property.type.Contains("bool")) {#>
            mock<#= thisClassName #>.Setup(m => m.<#= property.name #>).Returns(() => true);
<#+		} else { #>
            mock<#= thisClassName #>.Setup(m => m.<#= property.name #>).Returns(() => "<#= property.name #>");
<#+		} #>
<#+	} // End Foreach loop (var property in entityClass.properties) // Properties #>
<#+	if (!hasProperties) { #>
            // <None>
<#+	} // End If (!hasProperties) #>
            // Related Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsRelatedObjectProperty(property, out propertyType)) { continue; }
		hasRelatedProperties = true; #>
<#+		if (IsIdentifierProperty(property)) {#>
            mock<#= thisClassName #>.Setup(m => m.<#= property.name #>).Returns(() => 1);
<#+		} else {#>
            mock<#= thisClassName #>.Setup(m => m.<#= property.name #>).Returns(() => new <#= property.type.Replace("DataModel.Schema.", "") #>());
<#+		} #>
<#+	} // End Foreach loop (var property in entityClass.properties) // Related #>
<#+	if (!hasRelatedProperties) { #>
            // <None>
<#+	} // End If (!hasRelatedProperties) #>
            // Associated Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsAssociatedObjectProperty(property, out propertyType)) { continue; }
		var type = propertyType.Replace("List<", "").Replace(">", "").Replace("DataModel.", "").Replace("Model", "");
		hasAssociatedProperties = true; #>
            mock<#= thisClassName #>.Setup(m => m.<#= property.name #>).Returns(() => new <#= property.type.Replace("DataModel.Schema.", "").Replace("List<", "List<I") #>());
<#+	} // End Foreach loop (var property in entityClass.properties) // Associated #>
<#+	if (!hasAssociatedProperties) { #>
            // <None>
<#+	} // End If (!hasAssociatedProperties) #>
            // Return
            return mock<#= thisClassName #>;
        }
    }

    public class <#= thisClassName #>MappingExtensionsTests
    {
        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_MapToEntityExtension_CallsMapToEntity()
        {
            // Arrange
            var mockMapper = new Mock<<#= thisClassName #>Mapper>();
            mockMapper.Setup(x => x.MapToEntity(It.IsAny<I<#= thisClassName #>Model>(), It.IsAny<int>()));
            var mockModel = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>Model(1);
            <#= thisClassName #>MapperExtensions.OverrideMapper(mockMapper.Object);
            // Act
            mockModel.Object.MapToEntity();
            // Assert
            mockMapper.Verify(x => x.MapToEntity(It.IsAny<I<#= thisClassName #>Model>(), It.IsAny<int>()), Times.Once);
        }

        //[Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        //public void Verify_MapToEntityWithExistingExtension_CallsMapToEntity()
        //{
        //    // Arrange
        //    var mockMapper = new Mock<<#= thisClassName #>Mapper>();
        //    mockMapper.Setup(x => x.MapToEntity(It.IsAny<I<#= thisClassName #>Model>(), ref It.IsAny<I<#= thisClassName #>>(), It.IsAny<int>()));
        //    var mockModel = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>Model(1);
        //    var mockEntity = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>(1);
        //    <#= thisClassName #>MapperExtensions.OverrideMapper(mockMapper.Object);
        //    // Act
        //    mockModel.Object.MapToEntity(ref mockEntity);
        //    // Assert
        //    mockMapper.Verify(x => x.MapToEntity(It.IsAny<I<#= thisClassName #>Model>(), ref It.IsAny<I<#= thisClassName #>>(), It.IsAny<int>()), Times.Once);
        //}

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_MapToModelExtension_CallsMapToModel()
        {
            // Arrange
            var mockMapper = new Mock<<#= thisClassName #>Mapper>();
            mockMapper.Setup(x => x.MapToModel(It.IsAny<I<#= thisClassName #>>(), It.IsAny<int>()));
            var mockEntity = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>(1);
            <#= thisClassName #>MapperExtensions.OverrideMapper(mockMapper.Object);
            // Act
            mockEntity.Object.MapToModel();
            // Assert
            mockMapper.Verify(x => x.MapToModel(It.IsAny<I<#= thisClassName #>>(), It.IsAny<int>()), Times.Once);
        }

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_MapToModelLiteExtension_CallsMapToModel()
        {
            // Arrange
            var mockMapper = new Mock<<#= thisClassName #>Mapper>();
            mockMapper.Setup(x => x.MapToModelLite(It.IsAny<I<#= thisClassName #>>(), It.IsAny<int>()));
            var mockEntity = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>(1);
            <#= thisClassName #>MapperExtensions.OverrideMapper(mockMapper.Object);
            // Act
            mockEntity.Object.MapToModelLite();
            // Assert
            mockMapper.Verify(x => x.MapToModelLite(It.IsAny<I<#= thisClassName #>>(), It.IsAny<int>()), Times.Once);
        }

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_MapToModelListingExtension_CallsMapToModel()
        {
            // Arrange
            var mockMapper = new Mock<<#= thisClassName #>Mapper>();
            mockMapper.Setup(x => x.MapToModelListing(It.IsAny<I<#= thisClassName #>>(), It.IsAny<int>()));
            var mockEntity = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>(1);
            <#= thisClassName #>MapperExtensions.OverrideMapper(mockMapper.Object);
            // Act
            mockEntity.Object.MapToModelListing();
            // Assert
            mockMapper.Verify(x => x.MapToModelListing(It.IsAny<I<#= thisClassName #>>(), It.IsAny<int>()), Times.Once);
        }

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_MapToSearchModelExtension_CallsMapToModel()
        {
            // Arrange
            var mockMapper = new Mock<<#= thisClassName #>Mapper>();
            mockMapper.Setup(x => x.MapToSearchModel(It.IsAny<I<#= thisClassName #>Model>()));
            var mockModel = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>Model(1);
            <#= thisClassName #>MapperExtensions.OverrideMapper(mockMapper.Object);
            // Act
            mockModel.Object.MapToSearchModel();
            // Assert
            mockMapper.Verify(x => x.MapToSearchModel(It.IsAny<I<#= thisClassName #>Model>()), Times.Once);
        }

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_AreEqualExtension_CallsAreEqual()
        {
            // Arrange
            var mockMapper = new Mock<<#= thisClassName #>Mapper>();
            mockMapper.Setup(x => x.AreEqual(It.IsAny<I<#= thisClassName #>Model>(), It.IsAny<I<#= thisClassName #>>()));
            <#= thisClassName #>MapperExtensions.OverrideMapper(mockMapper.Object);
            var mockModel = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>Model(1);
            var mockEntity = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>(1);
            // Act
            mockModel.Object.AreEqual(mockEntity.Object);
            // Assert
            mockMapper.Verify(x => x.AreEqual(It.IsAny<I<#= thisClassName #>Model>(), It.IsAny<I<#= thisClassName #>>()), Times.Once);
        }
    }

    public class <#= thisClassNamePluralized #>MappingTests
    {
        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_MapToEntity_Assigns<#= thisClassName #>Properties()
        {
            // Arrange
            var mapper = new <#= thisClassName #>Mapper();
            var model = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>Model();
            // Act
            var entity = mapper.MapToEntity(model.Object);
            // Assert
<#+	foreach (var property in entityClass.properties) {
		if (!IsClassProperty(property, out propertyType)) { continue; }
		hasProperties = true; #>
            Assert.Equal(model.Object.<#= property.name #>, entity.<#= property.name #>);
<#+	} // End Foreach loop (var property in entityClass.properties) // Properties #>
<#+	if (!hasProperties) { #>
            // <None>
<#+	} // End If (!hasProperties) #>
            // Related Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsRelatedObjectProperty(property, out propertyType)) { continue; }
		hasRelatedProperties = true; #>
<#+		if (IsIdentifierProperty(property)) {#>
            Assert.Equal(model.Object.<#= property.name #>, entity.<#= property.name #>);
<#+		} #>
<#+	} // End Foreach loop (var property in entityClass.properties) // Related #>
<#+	if (!hasRelatedProperties) { #>
            // <None>
<#+	} // End If (!hasRelatedProperties) #>
            // Associated Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsAssociatedObjectProperty(property, out propertyType)) { continue; }
		var type = propertyType.Replace("List<", "").Replace(">", "").Replace("DataModel.", "").Replace("Model", "");
		hasAssociatedProperties = true; #>
            //Assert.Equal(model.Object.<#= property.name #>?.Count, entity.<#= property.name #>?.Count);
            model.VerifyGet(x => x.<#= property.name #>, Times.Once);
<#+	} // End Foreach loop (var property in entityClass.properties) // Associated #>
<#+	if (!hasAssociatedProperties) { #>
            // <None>
<#+	} // End If (!hasAssociatedProperties) #>
        }

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_MapToEntity_WithExistingEntity_Assigns<#= thisClassName #>Properties()
        {
            // Arrange
            var mapper = new <#= thisClassName #>Mapper();
            var model = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>Model();
            // Act
            I<#= thisClassName #> existingEntity = new <#= thisClassName #> { Id = 1 };
            mapper.MapToEntity(model.Object, ref existingEntity);
            // Assert
<#+	foreach (var property in entityClass.properties) {
		if (!IsClassProperty(property, out propertyType)) { continue; }
		hasProperties = true; #>
            Assert.Equal(model.Object.<#= property.name #>, existingEntity.<#= property.name #>);
<#+	} // End Foreach loop (var property in entityClass.properties) // Properties #>
<#+	if (!hasProperties) { #>
            // <None>
<#+	} // End If (!hasProperties) #>
            // Related Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsRelatedObjectProperty(property, out propertyType)) { continue; }
		hasRelatedProperties = true; #>
<#+		if (IsIdentifierProperty(property)) {#>
            Assert.Equal(model.Object.<#= property.name #>, existingEntity.<#= property.name #>);
<#+		} #>
<#+	} // End Foreach loop (var property in entityClass.properties) // Related #>
<#+	if (!hasRelatedProperties) { #>
            // <None>
<#+	} // End If (!hasRelatedProperties) #>
            // Associated Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsAssociatedObjectProperty(property, out propertyType)) { continue; }
		var type = propertyType.Replace("List<", "").Replace(">", "").Replace("DataModel.", "").Replace("Model", "");
		hasAssociatedProperties = true; #>
            model.VerifyGet(x => x.<#= property.name #>, Times.Once);
            //Assert.Equal(model.Object.<#= property.name #>?.Count, existingEntity.<#= property.name #>?.Count);
<#+	} // End Foreach loop (var property in entityClass.properties) // Associated #>
<#+	if (!hasAssociatedProperties) { #>
            // <None>
<#+	} // End If (!hasAssociatedProperties) #>
        }

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_MapToModel_Assigns<#= thisClassName #>Properties()
        {
            // Arrange
            var mapper = new <#= thisClassName #>Mapper();
            var entity = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>();
            // Act
            var model = mapper.MapToModel(entity.Object);
            // Assert
<#+	foreach (var property in entityClass.properties) {
		if (!IsClassProperty(property, out propertyType)) { continue; }
		hasProperties = true; #>
            Assert.Equal(entity.Object.<#= property.name #>, model.<#= property.name #>);
<#+	} // End Foreach loop (var property in entityClass.properties) // Properties #>
<#+	if (!hasProperties) { #>
            // <None>
<#+	} // End If (!hasProperties) #>
            // Related Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsRelatedObjectProperty(property, out propertyType)) { continue; }
		hasRelatedProperties = true; #>
<#+		if (IsIdentifierProperty(property)) {#>
            Assert.Equal(entity.Object.<#= property.name #>, model.<#= property.name #>);
<#+		} #>
<#+	} // End Foreach loop (var property in entityClass.properties) // Related #>
<#+	if (!hasRelatedProperties) { #>
            // <None>
<#+	} // End If (!hasRelatedProperties) #>
            // Associated Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsAssociatedObjectProperty(property, out propertyType)) { continue; }
		var type = propertyType.Replace("List<", "").Replace(">", "").Replace("DataModel.", "").Replace("Model", "");
		hasAssociatedProperties = true; #>
            Assert.Equal(entity.Object.<#= property.name #>?.Count, model.<#= property.name #>?.Count);
<#+	} // End Foreach loop (var property in entityClass.properties) // Associated #>
<#+	if (!hasAssociatedProperties) { #>
            // <None>
<#+	} // End If (!hasAssociatedProperties) #>
        }

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_MapToModelLite_AssignsLiteOnly<#= thisClassName #>Properties()
        {
            // Arrange
            var mapper = new <#= thisClassName #>Mapper();
            var entity = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>();
            // Act
            var model = mapper.MapToModelLite(entity.Object);
            // Assert
<#+	foreach (var property in entityClass.properties) {
		if (!IsClassProperty(property, out propertyType)) { continue; }
		hasProperties = true; #>
            Assert.Equal(entity.Object.<#= property.name #>, model.<#= property.name #>);
<#+	} // End Foreach loop (var property in entityClass.properties) // Properties #>
<#+	if (!hasProperties) { #>
            // <None>
<#+	} // End If (!hasProperties) #>
            // Related Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsRelatedObjectProperty(property, out propertyType)) { continue; }
		hasRelatedProperties = true; #>
<#+		if (IsIdentifierProperty(property)) {#>
            Assert.Equal(entity.Object.<#= property.name #>, model.<#= property.name #>);
<#+		} #>
<#+	} // End Foreach loop (var property in entityClass.properties) // Related #>
<#+	if (!hasRelatedProperties) { #>
            // <None>
<#+	} // End If (!hasRelatedProperties) #>
        }

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_MapToModelListing_AssignsListingOnly<#= thisClassName #>Properties()
        {
            // Arrange
            var mapper = new <#= thisClassName #>Mapper();
            var entity = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>();
            // Act
            var model = mapper.MapToModelListing(entity.Object);
            // Assert
<#+	foreach (var property in entityClass.properties) {
		if (!IsClassProperty(property, out propertyType)) { continue; }
		hasProperties = true; #>
            Assert.Equal(entity.Object.<#= property.name #>, model.<#= property.name #>);
<#+	} // End Foreach loop (var property in entityClass.properties) // Properties #>
<#+	if (!hasProperties) { #>
            // <None>
<#+	} // End If (!hasProperties) #>
            // Related Objects
<#+	foreach (var property in entityClass.properties) {
		if (!IsRelatedObjectProperty(property, out propertyType)) { continue; }
		hasRelatedProperties = true; #>
<#+		if (IsIdentifierProperty(property)) {#>
            Assert.Equal(entity.Object.<#= property.name #>, model.<#= property.name #>);
<#+		} #>
<#+	} // End Foreach loop (var property in entityClass.properties) // Related #>
<#+	if (!hasRelatedProperties) { #>
            // <None>
<#+	} // End If (!hasRelatedProperties) #>
            // Return Entity
        }

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_MapToSearchModel_Assigns<#= thisClassName #>SearchProperties()
        {
            // Arrange
            var mapper = new <#= thisClassName #>Mapper();
            var model = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>Model();
            // Act
            var searchModel = mapper.MapToSearchModel(model.Object);
            // Assert
<#+	if (hasRelatedProperties) { #>
<#+		foreach (var property in entityClass.properties) {
			if (!IsRelatedObjectProperty(property, out propertyType)) { continue; }
			var nameNoID = property.name.Replace("Id", "").Replace("ID", "");
			if (IsIdentifierProperty(property)) { #>
            Assert.Equal(model.Object.<#= property.name #>, searchModel.<#= property.name #>);
<#+				if (entityClass.properties.Any(p => p.name == nameNoID)) { #>
            Assert.Equal(model.Object.<#= property.name.Replace("Id", "?.CustomKey").Replace("ID", "?.CustomKey") #>, searchModel.<#= property.name.Replace("Id", "CustomKey").Replace("ID", "CustomKey") #>);
<#+				} // End If (entityClass.properties.Any(p => p.name == nameNoID)) #>
<#+				if (property.name == "RequiredLevelId") {#>
            Assert.Equal(model.Object.LevelMin, searchModel.LevelMin);
            Assert.Equal(model.Object.LevelMax, searchModel.LevelMax);
<#+				} // End If (property.name == "RequiredLevelId") #>
<#+			} // End If (IsIdentifierProperty(property)) #>
<#+			if (property.isNameable) { #>
            Assert.Equal(model.Object.<#= property.name #>?.ApiDetailUrl, searchModel.<#= property.name #>ApiDetailUrl);
            Assert.Equal(model.Object.<#= property.name #>?.SiteDetailUrl, searchModel.<#= property.name #>SiteDetailUrl);
            Assert.Equal(model.Object.<#= property.name #>?.Name, searchModel.<#= property.name #>Name);
            Assert.Equal(model.Object.<#= property.name #>?.ShortDescription, searchModel.<#= property.name #>ShortDescription);
            Assert.Equal(model.Object.<#= property.name #>?.Description, searchModel.<#= property.name #>Description);
<#+			} // End If (property.isNameable) #>
<#+			if (property.isContactable) { #>
            Assert.Equal(model.Object.<#= property.name #>?.Phone, searchModel.<#= property.name #>Phone);
            Assert.Equal(model.Object.<#= property.name #>?.Fax, searchModel.<#= property.name #>Fax);
            Assert.Equal(model.Object.<#= property.name #>?.Email, searchModel.<#= property.name #>Email);
<#+			} // End If (property.isContactable) #>
<#+		} // End Foreach Loop (var property in entityClass.properties) // Related #>
<#+	} // End If (hasRelatedProperties) #>
<#+	foreach (var property in entityClass.properties) {
		if (!property.isFilterable) { continue; }
		var filterNameTitle = string.IsNullOrWhiteSpace(property.filterName) ? property.name : property.filterName;
		var filterName = string.IsNullOrWhiteSpace(property.filterName) ? property.name.ToLower() : property.filterName.ToLower();
		var filterDescription = string.IsNullOrWhiteSpace(property.filterDescription) ? string.Format("The {0} to search by.", property.name) : property.filterDescription; #>
<#+		if (property.type == "string") { #>
            Assert.Equal(model.Object.<#= filterNameTitle #>, searchModel.<#= filterNameTitle #>);
<#+		} #>
<#+		if (property.type == "int" || property.type == "int?" || property.type == "bool" || property.type == "bool?" || property.type == "decimal" || property.type == "decimal?") { #>
            Assert.Equal(model.Object.<#= filterNameTitle #>, searchModel.<#= filterNameTitle #>);
<#+		} #>
<#+	} // End ForEach Loop (var property in entityClass.properties) // Searchable #>
        }

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_AreEqual_WithEqualObjects_ReturnsTrue()
        {
            // Arrange
            var mapper = new <#= thisClassName #>Mapper();
            var model = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>Model(1);
            var entity = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>(1);
            // Act
            var result = mapper.AreEqual(model.Object, entity.Object);
            // Assert
            Assert.True(result);
        }

        [Fact][Trait("Category", "<#= thisClassNamePluralized #>")]
        public void Verify_AreEqual_WithDifferentObjects_ReturnsFalse()
        {
            // Arrange
            var mapper = new <#= thisClassName #>Mapper();
            var model = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>Model(1);
            var entity = <#= thisClassNamePluralized #>MockingSetup.DoMockingSetupFor<#= thisClassName #>(2);
            // Act
            var result = mapper.AreEqual(model.Object, entity.Object);
            // Assert
            Assert.False(result);
        }
    }
}
<#+
} // End Function GenerateInterfaceFile
#>